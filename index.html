<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Pong Replica</title>
  <style>
    :root {
      --bg:#0b0f14; --fg:#e8f0ff; --accent:#66e2a3; --muted:#5b7188;
    }
    * { box-sizing: border-box; }
    html, body { height:100%; }
    body {
      margin:0; display:grid; place-items:center; background:radial-gradient(1200px 800px at 50% 40%, #111a24, var(--bg)); color:var(--fg);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
    }
    .wrap { width:min(96vw, 900px); }
    header { display:flex; align-items:center; justify-content:space-between; gap:1rem; margin: 12px 0; }
    h1 { font-size:clamp(18px, 3vw, 24px); letter-spacing:.04em; margin:0; color:var(--fg); }
    .controls { display:flex; flex-wrap:wrap; gap:.5rem; align-items:center; }
    button, select { background:#121a24; color:var(--fg); border:1px solid #263242; padding:.5rem .8rem; border-radius:12px; cursor:pointer; font-weight:600; }
    button:hover { border-color:#33475e; }
    .pill { font-size:12px; color:var(--muted); }
    canvas { width:100%; height:auto; display:block; border-radius:18px; box-shadow:0 10px 30px rgba(0,0,0,.45); background:
      linear-gradient(transparent 49.5%, rgba(255,255,255,.15) 49.5%, rgba(255,255,255,.15) 50.5%, transparent 50.5%),
      radial-gradient(circle at 50% 50%, rgba(102,226,163,.1), transparent 200px),
      #0a0f14; }
    .hud { margin-top:10px; display:flex; justify-content:space-between; align-items:center; color:var(--muted); font-size:14px; }
    .score { font-size: clamp(24px, 6vw, 42px); font-weight:800; letter-spacing:.08em; color:var(--fg); text-shadow:0 0 18px rgba(102,226,163,.25); }
    .kbd { background:#101820; border:1px solid #243142; border-bottom-width:3px; padding:.15rem .35rem; border-radius:6px; font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size:12px; color:#c9d7ee; }
    .toast { position:absolute; inset:0; display:none; place-items:center; pointer-events:none; }
    .toast.show { display:grid; }
    .toast > div { background:rgba(4,8,12,.72); padding:16px 20px; border:1px solid #243142; border-radius:14px; backdrop-filter: blur(6px); }
    a { color:var(--accent); text-decoration:none; }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>Pong Replica</h1>
      <div class="controls">
        <label class="pill">Mode:
          <select id="mode">
            <option value="cpu">1P vs CPU</option>
            <option value="pvp">2 Players</option>
          </select>
        </label>
        <label class="pill">Target Score:
          <select id="target">
            <option>5</option>
            <option selected>11</option>
            <option>21</option>
          </select>
        </label>
        <button id="btnPause" title="Space">Pause</button>
        <button id="btnReset">Reset</button>
      </div>
    </header>

    <canvas id="game" width="900" height="540" aria-label="Pong game area" role="img"></canvas>

    <div class="hud">
      <div>
        <span class="kbd">W</span> / <span class="kbd">S</span> — Left paddle &nbsp;•&nbsp; <span class="kbd">↑</span> / <span class="kbd">↓</span> — Right paddle
      </div>
      <div>Press <span class="kbd">Space</span> to pause • <span class="kbd">R</span> to reset</div>
    </div>

    <div class="toast" id="toast">
      <div id="toastText"></div>
    </div>
  </div>

<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const modeSel = document.getElementById('mode');
  const targetSel = document.getElementById('target');
  const btnPause = document.getElementById('btnPause');
  const btnReset = document.getElementById('btnReset');
  const toast = document.getElementById('toast');
  const toastText = document.getElementById('toastText');

  // ==== SOUND: simple multi-voice player for modern FX (option 2) ====
  class MultiAudio {
    constructor(src, voices = 4, volume = 0.7) {
      this.pool = Array.from({ length: voices }, () => {
        const a = new Audio(src);
        a.preload = 'auto';
        a.volume = volume;
        return a;
      });
      this.i = 0;
    }
    play() {
      try {
        const a = this.pool[this.i];
        this.i = (this.i + 1) % this.pool.length;
        a.currentTime = 0;
        a.play();
      } catch (e) {
        // ignore autoplay errors; browser may require interaction first
      }
    }
  }

  // Place these files beside your HTML: hit.wav, wall.wav, score.wav
  const SFX = {
    hit:   new MultiAudio('hit.wav',   6, 0.75),
    wall:  new MultiAudio('wall.wav',  4, 0.55),
    score: new MultiAudio('score.wav', 3, 0.8),
  };

  // ==== RENDERING SCALE ====
  function fitDPR() {
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    const rect = canvas.getBoundingClientRect();
    canvas.width = Math.round(rect.width * dpr);
    canvas.height = Math.round(rect.width * 0.6 * dpr); // 15:9 aspect
    scale = dpr;
  }
  let scale = 1;
  window.addEventListener('resize', fitDPR);
  fitDPR();

  // Game constants
  const W = () => canvas.width, H = () => canvas.height;
  const PADDLE_W = () => 14 * scale;
  const PADDLE_H = () => 110 * scale;
  const BALL_R = () => 8 * scale;

  let leftScore = 0, rightScore = 0;
  let targetScore = parseInt(targetSel.value, 10);
  let mode = modeSel.value; // 'cpu' | 'pvp'
  let paused = false;
  let gameOver = false;
  let hitCount = 0; // counts paddle hits to reflect speed-ups

  const keys = new Set();
  window.addEventListener('keydown', (e) => {
    const k = e.key.toLowerCase();
    if (["w","s","arrowup","arrowdown"," ","r"].includes(k)) e.preventDefault();
    keys.add(k);
    if (k === ' ') togglePause();
    if (k === 'r') reset(true);
  });
  window.addEventListener('keyup', (e) => keys.delete(e.key.toLowerCase()));

  btnPause.addEventListener('click', () => togglePause());
  btnReset.addEventListener('click', () => reset(true));
  modeSel.addEventListener('change', () => { mode = modeSel.value; });
  targetSel.addEventListener('change', () => { targetScore = parseInt(targetSel.value, 10); reset(true); });

  function randSign(){ return Math.random() < 0.5 ? -1 : 1; }

  // Entities
  const left = { x: 30, y: 0, w: PADDLE_W(), h: PADDLE_H(), speed: 620, dy: 0 };
  const right = { x: 0, y: 0, w: PADDLE_W(), h: PADDLE_H(), speed: 620, dy: 0 };
  const ball = { x: 0, y: 0, r: BALL_R(), vx: 0, vy: 0, speed: 520 };

  // Particle system
  const particles = [];
  function speedNow(){ return Math.hypot(ball.vx, ball.vy); }
  const SPEED_MIN = 380; // baseline for color map
  const SPEED_MAX = 1200; // red cap
  function lerp(a,b,t){ return a + (b-a)*t; }
  function clamp(v,min,max){ return Math.max(min, Math.min(max, v)); }
  function speedColor(s){
    const t = clamp((s - SPEED_MIN) / (SPEED_MAX - SPEED_MIN), 0, 1);
    // Hue 220 (blue) -> 0 (red)
    const hue = lerp(220, 0, t);
    return `hsl(${hue}, 90%, 60%)`;
  }
  function emitParticles(n, spread = 0.9) {
    const spd = speedNow();
    const col = speedColor(spd);
    for (let i=0;i<n;i++){
      const ang = Math.atan2(ball.vy, ball.vx) + (Math.random()-0.5) * spread;
      const mag = 80 + Math.random()*160;
      particles.push({
        x: ball.x, y: ball.y,
        vx: Math.cos(ang) * mag * 0.5,
        vy: Math.sin(ang) * mag * 0.5,
        life: 0.9 + Math.random()*0.5,
        size: 3*scale + Math.random()*2*scale,
        color: col,
        alpha: 0.9
      });
    }
  }
  function updateParticles(dt){
    for (let i=particles.length-1;i>=0;i--){
      const p = particles[i];
      p.x += p.vx * dt; p.y += p.vy * dt;
      p.vx *= 0.98; p.vy *= 0.98; // slight drag
      p.life -= dt; p.alpha = clamp(p.life, 0, 1);
      if (p.life <= 0 || p.x< -50 || p.x>W()+50 || p.y < -50 || p.y>H()+50){ particles.splice(i,1); }
    }
  }
  function drawParticles(){
    ctx.save();
    ctx.globalCompositeOperation = 'lighter';
    for (const p of particles){
      ctx.globalAlpha = p.alpha * 0.8;
      ctx.fillStyle = p.color;
      ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI*2); ctx.fill();
    }
    ctx.restore();
  }

  function centerPaddles(){
    left.y = (H() - left.h) / 2; left.x = 40 * scale;
    right.y = (H() - right.h) / 2; right.x = W() - right.w - 40 * scale;
  }

  function serve(dir = randSign()){
    ball.x = W()/2; ball.y = H()/2; ball.r = BALL_R();
    const angle = (Math.random() * 0.4 - 0.2); // -0.2..0.2 rad around 0
    const sp = ball.speed * (0.9 + Math.random()*0.2);
    ball.vx = Math.cos(angle) * sp * dir;
    ball.vy = Math.sin(angle) * sp * randSign();
  }

  function reset(full=false){
    leftScore = full ? 0 : leftScore;
    rightScore = full ? 0 : rightScore;
    hitCount = 0;
    gameOver = false;
    paused = false; // Reset paused state
    left.w = PADDLE_W(); left.h = PADDLE_H(); right.w = PADDLE_W(); right.h = PADDLE_H();
    left.speed = right.speed = 620;
    particles.length = 0;
    centerPaddles();
    serve(randSign());
    hideToast(); // Ensure toast is hidden on reset
  }

  function togglePause(){
    if (gameOver) return; // Don't allow pausing when game is over
    paused = !paused;
    if (paused) {
      showToast('Paused');
    } else {
      hideToast();
    }
  }

  function showToast(text){ 
    toastText.textContent = text; 
    toast.classList.add('show');
  }
  
  function hideToast(){ 
    toast.classList.remove('show');
    toastText.textContent = ''; // Clear the text content too
  }

  // CPU logic
  function rectCircleCollide(rx, ry, rw, rh, cx, cy, cr){
    const nx = clamp(cx, rx, rx+rw);
    const ny = clamp(cy, ry, ry+rh);
    const dx = cx - nx, dy = cy - ny;
    return (dx*dx + dy*dy) <= cr*cr;
  }
  function cpuMove(p, dt){
    const reaction = 0.18; // lower = smarter
    const targetY = ball.y - p.h/2 + ball.vy * reaction; // anticipate
    const diff = targetY - p.y;
    const max = p.speed * dt;
    if (Math.abs(diff) > 2) p.y += clamp(diff, -max, max);
  }

  // Drawing
  function draw(){
    // Court
    ctx.clearRect(0,0,W(),H());
    ctx.fillStyle = '#0b0f14';
    ctx.fillRect(0,0,W(),H());

    // Center line
    ctx.globalAlpha = 0.25; ctx.fillStyle = '#ffffff';
    const dashH = 18*scale, gap = 14*scale, lineW = 6*scale;
    for(let y=gap; y<H(); y+=dashH+gap){ ctx.fillRect(W()/2 - lineW/2, y, lineW, dashH); }
    ctx.globalAlpha = 1;

    // Glow circles
    ctx.globalAlpha = 0.08; ctx.beginPath(); ctx.arc(W()/2, H()/2, 180*scale, 0, Math.PI*2); ctx.fill(); ctx.globalAlpha = 1;

    // Particles first (so paddles/ball render top) or last? We'll render beneath the ball but above court
    drawParticles();

    // Paddles
    ctx.fillStyle = '#e8f0ff';
    ctx.fillRect(left.x, left.y, left.w, left.h);
    ctx.fillRect(right.x, right.y, right.w, right.h);

    // Ball with speed-color rim
    ctx.save();
    const spd = speedNow();
    const col = speedColor(spd);
    ctx.beginPath(); ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI*2);
    ctx.fillStyle = '#e8f0ff'; ctx.fill();
    ctx.lineWidth = 3*scale; ctx.strokeStyle = col; ctx.stroke();
    ctx.restore();

    // Score
    ctx.fillStyle = '#e8f0ff'; ctx.font = `${48*scale}px system-ui, sans-serif`;
    ctx.textAlign = 'center'; ctx.textBaseline = 'top';
    ctx.fillText(`${leftScore}`, W()/2 - 80*scale, 16*scale);
    ctx.fillText(`${rightScore}`, W()/2 + 80*scale, 16*scale);

    if (gameOver) {
      ctx.font = `${28*scale}px system-ui, sans-serif`;
      ctx.textBaseline = 'middle';
      ctx.fillText(`${leftScore>rightScore? 'Left' : 'Right'} player wins! Press R to restart.`, W()/2, H()/2 + 40*scale);
    }
  }

  // Update
  let last = performance.now();
  function loop(t){
    const dt = Math.min(0.02, (t - last) / 1000); // clamp to 20ms
    last = t;
    if (!paused && !gameOver) update(dt);
    draw();
    requestAnimationFrame(loop);
  }

  function update(dt){
    // Input: Left paddle
    left.dy = (keys.has('w') ? -1 : 0) + (keys.has('s') ? 1 : 0);
    left.y += left.dy * left.speed * dt;

    // Input / CPU: Right paddle
    if (mode === 'pvp') {
      right.dy = (keys.has('arrowup') ? -1 : 0) + (keys.has('arrowdown') ? 1 : 0);
      right.y += right.dy * right.speed * dt;
    } else {
      cpuMove(right, dt);
    }

    // Clamp paddles inside
    left.y = clamp(left.y, 10*scale, H() - left.h - 10*scale);
    right.y = clamp(right.y, 10*scale, H() - right.h - 10*scale);

    // Move ball
    ball.x += ball.vx * dt; ball.y += ball.vy * dt;

    // Emit continuous trail based on speed and hit count (more hits = denser)
    const baseEmit = 1 + Math.floor((speedNow() - SPEED_MIN) / 120);
    const extra = Math.min(12, Math.floor(hitCount * 0.5));
    if ((performance.now() % 2) < 1) emitParticles(baseEmit + extra); // throttle a bit

    // Wall bounce
    if (ball.y - ball.r <= 0) { ball.y = ball.r; ball.vy *= -1; SFX.wall.play(); emitParticles(10, 1.2); }
    if (ball.y + ball.r >= H()) { ball.y = H() - ball.r; ball.vy *= -1; SFX.wall.play(); emitParticles(10, 1.2); }

    // Paddle collisions
    // Left
    if (rectCircleCollide(left.x, left.y, left.w, left.h, ball.x, ball.y, ball.r) && ball.vx < 0) {
      ball.x = left.x + left.w + ball.r;
      hitPaddle(left);
    }
    // Right
    if (rectCircleCollide(right.x, right.y, right.w, right.h, ball.x, ball.y, ball.r) && ball.vx > 0) {
      ball.x = right.x - ball.r;
      hitPaddle(right);
    }

    // Score
    if (ball.x + ball.r < 0) { rightScore++; scorePoint(1); }
    if (ball.x - ball.r > W()) { leftScore++; scorePoint(-1); }

    updateParticles(dt);
  }

  function hitPaddle(p){
    // add spin based on impact point
    const hit = ((ball.y - (p.y + p.h/2)) / (p.h/2)); // -1..1
    const angle = hit * 0.8; // max ~46deg
    const sp = Math.hypot(ball.vx, ball.vy) * 1.06 + 16; // accelerate slightly more each hit
    const dir = (p === left) ? 1 : -1;
    ball.vx = Math.cos(angle) * sp * dir;
    ball.vy = Math.sin(angle) * sp;
    hitCount++;
    SFX.hit.play();
    emitParticles(28 + Math.min(24, hitCount));
  }

  function scorePoint(lastDir){
    SFX.score.play();
    if (leftScore >= targetScore || rightScore >= targetScore) {
      gameOver = true; 
      showToast(`${leftScore>rightScore? 'Left' : 'Right'} player wins!`); 
      return;
    }
    hitCount = 0; // reset acceleration count
    centerPaddles();
    serve(-lastDir); // serve toward player who was scored on
  }

  // Init - Make sure toast is hidden initially
  hideToast();
  reset(true);
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
